package route

import (
	"fmt"
	"reflect"
	"strings"
)

type handlerMethod struct {
	in    *reflect.Type
	out   []*reflect.Type
	value reflect.Value
}

type route struct {
	handler *handlerMethod
}

type radixNode struct {
	part     string
	isEnd    bool
	children map[string]*radixNode
	routes   map[string]*route
	param    string
}

type radixTree struct {
	root *radixNode
}

func NewRadixTree() *radixTree {
	return &radixTree{
		root: &radixNode{
			part:     "",
			children: make(map[string]*radixNode),
			routes:   make(map[string]*route),
		},
	}
}

func (t *radixTree) insert(path, method string, r *route) {
	if path == "/" {
		t.root.isEnd = true
		t.root.routes[method] = r
		return
	}
	t.insertRecursively(t.root, path, method, r)
}

func (t *radixTree) insertRecursively(node *radixNode, path, method string, r *route) {
	if len(path) == 0 {
		node.isEnd = true
		node.routes[method] = r
		return
	}

	// Check for parameter placeholder
	if strings.HasPrefix(path, "/:") || strings.HasPrefix(path, "/{") {

		paramName := ""
		// Find the parameter name
		if strings.HasPrefix(path, "/:") {
			paramName = path[2:]
		} else {
			paramName = path[2:strings.Index(path, "}")]
		}
		if node.param != "" {
			node.param = paramName
			node.routes[method] = r
			node.isEnd = true
			return
		}

		// Split parameter name and subpath
		var param, subPath string
		if strings.Contains(paramName, "/") {
			param = paramName[:strings.Index(paramName, "/")]
			subPath = paramName[strings.Index(paramName, "/"):]
		} else {
			param = paramName
			subPath = ""
		}
		paramNode := &radixNode{
			isEnd:    false,
			children: make(map[string]*radixNode),
			routes:   make(map[string]*route),
			param:    param,
		}
		// Handle parameter placeholders
		if strings.HasPrefix(path, "/:") {
			paramNode.part = "/:" + param
		} else if strings.HasPrefix(path, "/{") {
			paramNode.part = fmt.Sprintf("/{%s}", param)
		}
		node.part = node.part[:2]
		node.children[paramNode.part] = paramNode
		if len(subPath) > 0 {
			n := &radixNode{
				children: make(map[string]*radixNode),
				isEnd:    false,
				routes:   make(map[string]*route),
				part:     subPath,
			}
			var tempPath string
			if strings.HasPrefix(subPath, "/:") {
				tempPath = subPath[2:]
			} else if strings.HasPrefix(subPath, "/{") {
				tempPath = subPath[2:strings.Index(subPath, "}")]
			}
			n.param = tempPath
			paramNode.children[n.part] = n

			t.insertRecursively(n, subPath, method, r)
			return
		}
		paramNode.isEnd = true
		paramNode.routes[method] = r
		return
	}

	for _, child := range node.children {
		commonPrefix := findCommonPrefix(path, child.part)
		if commonPrefix > 0 {
			if commonPrefix == len(child.part) {
				t.insertRecursively(child, path[commonPrefix:], method, r)
			} else if commonPrefix == len(path) {
				t.insertRecursively(child, child.part[commonPrefix:], method, r)
				child.part = path
				child.isEnd = true
				child.routes[method] = r
			} else {
				newNode := &radixNode{
					part:     child.part[commonPrefix:],
					isEnd:    child.isEnd,
					children: child.children,
					routes:   child.routes,
					param:    child.param,
				}
				child.part = child.part[:commonPrefix]
				child.isEnd = false
				child.children[newNode.part] = newNode
				if commonPrefix < len(path) {
					t.insertRecursively(child, path[commonPrefix:], method, r)
				} else {
					child.isEnd = true
				}
			}
			return
		}
	}
	// No common prefix found, create a new node
	node.children[path] = &radixNode{
		part:     path,
		isEnd:    true,
		children: make(map[string]*radixNode),
		routes: map[string]*route{
			method: r,
		},
	}
}

func (t *radixTree) search(path, method string) (*route, map[string]string) {
	if path == "/" {
		if r, ok := t.root.routes[method]; ok {
			return r, nil
		}
		return nil, nil
	}
	return t.searchRecursively(t.root, path, method, make(map[string]string))
}

func (t *radixTree) searchRecursively(node *radixNode, path, method string, paramValue map[string]string) (*route, map[string]string) {
	if len(path) == 0 && node.isEnd {
		if r, ok := node.routes[method]; ok {
			return r, paramValue
		}
		return nil, nil
	}

	for _, child := range node.children {
		commonPrefix := findCommonPrefix(path, child.part)
		if commonPrefix > 0 {
			if commonPrefix == len(child.part) {
				return t.searchRecursively(child, path[commonPrefix:], method, paramValue)
			} else if commonPrefix == len(path) {
				return nil, nil
			}
		}
		if child.param != "" {
			if commonPrefix == 0 {
				continue
			}

			if child.isEnd {
				if r, ok := child.routes[method]; ok {
					if strings.LastIndex(path, "/") == strings.Index(path, "/") { // 判断寻找路径是不是到达最后
						paramValue[child.param] = path[strings.Index(path, "/")+1:]
						return r, paramValue
					}

				}
			}
			subPath := path[commonPrefix:]
			pathVal := subPath[:strings.Index(subPath, "/")]
			paramValue[child.param] = pathVal
			nextPath := subPath[strings.Index(subPath, "/"):]
			return t.searchRecursively(child, nextPath, method, paramValue)
		}
	}
	return nil, nil
}

func findCommonPrefix(s1, s2 string) int {
	minLen := len(s1)
	if len(s2) < minLen {
		minLen = len(s2)
	}
	for i := 0; i < minLen; i++ {
		if s1[i] != s2[i] {
			return i
		}
	}
	return minLen
}
